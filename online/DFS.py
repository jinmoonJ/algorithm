# DFS

# s : start
# V : 정점 개수
#   0 A B C D E F G
#   0 1 2 3 4 5 6 7
adj = [[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0, 0],
       [0, 1, 0, 0, 1, 1, 0, 0],
       [0, 1, 0, 0, 0, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 1, 0],
       [0, 0, 1, 1, 0, 0, 1, 0],
       [0, 0, 0, 0, 1, 1, 0, 1],
       [0, 0, 0, 0, 0, 0, 1, 0]

       ]


def dfs(s, V):
    # 정점의 방문 여부를 알기 위한 배열 선언
    visited = [0] * (V + 1)  # 0 번 인덱스는 사용 안함
    stack = []  # size xxx
    now = s  # 현재 위치는 now로 표현
    visited[now] = 1  # 시작 위치는 방문했다라고 체크
    print(now, end=" ")  # 시작 위치 출력

    # while len(stack) != 0 
    while now != 0:  # 현재 위치가 0이 아닐때까지 (무한 반복의 의미임) while True:와 같다.
        # 다음 방문위치를 방문
        for w in range(1, V + 1):  # 1 ~ V 번 정점 방문하기
            # 다음 방문 위치가 있고(1), 해당 방문위치를 방문한 적이 없으면
            if adj[now][w] == 1 and visited[w] == 0:
                # 다음 방문위치 처리
                # 현재 위치를 스택에 저장
                stack.append(now)
                # 다음 방문 위치를 방문했다고 체크
                visited[w] = 1
                print(w, end=" ")
                # 현재 위치를 다음 위치로 바꾸고
                now = w
        # 탈출
        else:
            # 다음 방문 위치가 없다 (방문했던 곳만 남거나, 아니면 인접한 곳이 아예없다)
            if stack:  # 스택이 비어있지 않으면 아직 방문할 곳이 남았다 라는 의미
                now = stack.pop()
            # 지난 정점으로 돌아가기
            else:  # 스택이 비어있다.  => 탐색 중지
                now = 0  # 무한 루프 중지

return

dfs(1, 7)
# 1 2 4 6 5 7 3
